(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{277:function(t,a,r){"use strict";r.r(a);var s=r(3),e=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"break和continue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#break和continue"}},[t._v("#")]),t._v(" break和continue")]),t._v(" "),a("p",[t._v("break 和 continue 语句为执行循环代码提供了更严格的控制手段。其中，break 语句用于立即退出循环，强制执行循环后的下一条语句。而 continue 语句也用于立即退出循环，但会再次从循环顶部开始执行。")]),t._v(" "),a("h2",{attrs:{id:"传递参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传递参数"}},[t._v("#")]),t._v(" 传递参数")]),t._v(" "),a("h3",{attrs:{id:"传递数值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传递数值"}},[t._v("#")]),t._v(" 传递数值")]),t._v(" "),a("p",[t._v("在函数外部定义一个参数count，这个参数被一个函数addTen(count)调用，在addTen中操作参数count，但这不会影响函数外部的原始变量 count，只不过是碰巧保存了同样的值。")]),t._v(" "),a("h3",{attrs:{id:"传递对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传递对象"}},[t._v("#")]),t._v(" 传递对象")]),t._v(" "),a("p",[t._v("在函数外部定义一个对象person，这个对象传入一个函数setName(person)，当函数内部给person设置了name属性，函数外部的person也会反映这个变，因为person指向的对象保存在全局作用域的堆内存上，很多开发者错误地认为，当在局部作用域中修改对象而变化反映到全局时，就意味着参数是按引用传递的。为证明对象是按值传递的。当 obj 在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。")]),t._v(" "),a("h2",{attrs:{id:"变量声明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量声明"}},[t._v("#")]),t._v(" 变量声明")]),t._v(" "),a("p",[t._v("在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在 with 语句中，最接近的上下文是函数上下文。"),a("strong",[t._v("如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文")])]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"垃圾回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),a("p",[t._v("确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。")]),t._v(" "),a("p",[t._v("垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用属于“不可判定”问题，意味着靠算法是解决不了的。")]),t._v(" "),a("p",[t._v("我们以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时就不再需要那个局部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略："),a("strong",[t._v("标记清理")]),t._v("和"),a("strong",[t._v("引用计数")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"标记清理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记清理"}},[t._v("#")]),t._v(" 标记清理")]),t._v(" "),a("p",[t._v("当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放他们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记")]),t._v(" "),a("h3",{attrs:{id:"引用计数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[t._v("#")]),t._v(" 引用计数")]),t._v(" "),a("p",[t._v("对每个值都记录它被引用的次数，声明变量并给它赋一个引用值，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。如果保存对该引值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法在访问到这个值了，因此可以安全地回收其内存了。")])])}),[],!1,null,null,null);a.default=e.exports}}]);